function toDashCase(e){return e.replace(/([a-zA-Z])(?=[A-Z])/g,"$1-").toLowerCase()}function has(e,t){return e.hasOwnProperty(t)}function empty(){return Object.create(null)}function freeze(e){return Object.freeze(e)}const EMPTY=freeze(empty());function isSerializableType(e){return e===String||e===Number||e===Boolean}const finalized=new WeakSet,reflectedProperties=new WeakMap,attributeToProperty=new Map,propertyToAttribute=new Map,AttributeMixin=e=>(class extends e{static get observedAttributes(){const e=this.properties||{};return Object.keys(e).filter(t=>isSerializableType(e[t].type)).map(e=>toDashCase(e))}static setup(){if(finalized.has(this)||!has(this,"properties"))return;const e=Object.keys(this.properties),t=new Set;for(const s of e){const{type:r,reflectToAttribute:i}=e[s];if(i||!1!==i&&isSerializable(r)){const e=toDashCase(s);propertyToAttribute.set(s,e),attributeToProperty.set(e,s),t.add(s)}}reflectedProperties.set(this,t),finalized.add(this)}constructor(){super(),this.constructor.setup()}connectedCallback(){const e=this.constructor;if(has(e,"properties")){const t=Object.keys(e.properties);for(const e of t){let s,r=null==this[e];const i=propertyToAttribute.get(e);if(r&&this.hasAttribute(i)){const a=this.getAttribute(i);this.removeAttribute(i);const{type:n}=t[e];switch(n){case String:s=a;break;case Number:s=Number(a);break;case Boolean:s=null!=a;break;default:s=JSON.parse(a)}(r=null==s)||(this[e]=s)}}}super.connectedCallback&&super.connectedCallback()}set(e,t){super.set(e,t),reflectedProperties.get(this.constructor).has(e)&&this.serialize(e,t)}serialize(e,t){const s=propertyToAttribute.get(e),{type:r}=this.constructor.properties[e];if(null!=r&&isSerializable(r))switch(r){case String:case Number:this.setAttribute(s,t);break;case Boolean:this.toggleAttribute(s,t)}}deserialize(e){const t=propertyToAttribute.get(e),{type:s}=this.constructor.properties[e];if(null!=s&&isSerializable(s))switch(s){case String:return this.getAttribute(t);case Number:return Number(this.getAttribute(t));case Boolean:return this.hasAttribute(t)}}attributeChangedCallback(e,t,s){const r=attributeToProperty.get(e);if(null!=r&&reflectedProperties.get(this.constructor).has(r)&&t!==s){const e=this.constructor.properties;let t;switch(e[r]&&e[r].type||String){case String:t=s;break;case Number:t=Number(s);break;case Boolean:t=null!=s}this[r]=t}super.attributeChangedCallback&&super.attributeChangedCallback(e,t,s)}toggleAttribute(e,t){null!=t?t?this.setAttribute(e,""):this.removeAttribute(e):this.hasAttribute(e)?this.removeAttribute(e):this.setAttribute(e,"")}}),batches=new WeakMap,debouncers=new WeakMap,AttributesChangedMixin=e=>(class extends e{constructor(){super(),PropertiesChangedElement.setup(),batches.set(this,empty())}attributeChangedCallback(e,t,s){const r=batches.get(this);null!=r[e]?r[e].newValue=s:r[e]={name:e,oldValue:t,newValue:s},clearTimeout(debouncers.get(this)),debouncers.set(this,setTimeout(()=>{this.attributesChangedCallback(r),batches.set(this,empty())},1))}attributesChangedCallback(e){}flushAttributeChanges(){clearTimeout(debouncers.get(this)),debouncers.delete(this),this.propertiesChangedCallback(batches.get(this)),batches.set(this,empty())}}),connector=e=>{const t=new WeakMap;return(s,r)=>(class extends s{connectedCallback(){const{selectors:s,actions:i}=r;if(s){const r=()=>Object.assign(this,s(e.getState()));t.set(this,e.subscribe(r)),r()}if(i){const t=i(e.dispatch);for(const e in t)this.addEventListener(e,s=>{s.stopImmediatePropagation(),t[e](s.detail)})}super.connectedCallback&&super.connectedCallback()}disconnectedCallback(){if(r.selectors){t.get(this)()}super.disconnectedCallback&&super.disconnectedCallback()}})},FocusMixin=e=>(class extends e{static get observedAttributes(){return(super.observedAttributes||[]).concat(["disabled"])}set disabled(e){e?this.setAttribute("disabled",""):this.removeAttribute("disabled")}get disabled(){return this.hasAttribute("disabled")}set focused(e){e?this.setAttribute("focused",""):this.removeAttribute("focused")}get focused(){return this.hasAttribute("focused")}attributeChangedCallback(e,t,s){if("disabled"===e){const e=null!=s;this.setAttribute("aria-disabled",e),e?(this.removeAttribute("tabindex"),this.blur()):this.setAttribute("tabindex","0")}super.attributeChangedCallback&&super.attributeChangedCallback(e,t,s)}connectedCallback(){this.addEventListener("focus",this.onFocus.bind(this)),this.addEventListener("blur",this.onBlur.bind(this)),this.hasAttribute("tabindex")||this.disabled||this.setAttribute("tabindex","0"),super.connectedCallback&&super.connectedCallback()}focus(){super.focus(),this.disabled||this.dispatchEvent(new Event("focus"))}onFocus(e){this.focused=!0}blur(){super.blur(),this.dispatchEvent(new Event("blur"))}onBlur(e){this.focused=!1}}),MinimalMixin=e=>(class extends e{emit(e,t,s){const r=Object.assign({bubbles:!0,cancelable:!0,detail:t},s);return this.dispatchEvent(new CustomEvent(e,r))}toggleAttribute(e,t){null!=t?t?this.setAttribute(e,""):this.removeAttribute(e):this.hasAttribute(e)?this.removeAttribute(e):this.setAttribute(e,"")}}),finalized$1=new WeakSet,observedProperties=new WeakMap,batches$1=new WeakMap,debouncers$1=new WeakMap,PropertiesChangedMixin=e=>(class t extends e{static setup(){if(!finalized$1.has(this)&&has(this,"properties")){if(this.observedProperties)observedProperties.set(this,new Set(this.observedProperties));else{const e=this.properties;observedProperties.set(this,new Set(Object.keys(e).filter(t=>!1!==e[t].observe)))}finalized$1.add(this)}}constructor(){super(),t.setup(),batches$1.set(this,empty())}connectedCallback(){null!=super.connectedCallback?super.connectedCallback():(console.error("PropertiesChangedMixin requires PropertyAccessorMixin to be applied first."),console.error("Source:",this));const e=this.constructor;if(!has(e,"properties"))return;const t=Object.keys(e.properties);for(const e of t){const s=t[e],{required:r}=s;null==this[e]&&has(s,"default")?this[e]=s.default.call(this):r&&console.warn(`Required property '${e}' was not passed down to`,this)}}set(e,t){if(super.set(e,t),!observedProperties.get(this.constructor).has(e))return;const s=batches$1.get(this);null!=s[name]?s[name].newValue=newValue:s[name]={name:name,oldValue:oldValue,newValue:newValue},clearTimeout(debouncers$1.get(this)),debouncers$1.set(this,setTimeout(()=>{this.propertiesChangedCallback(s),batches$1.set(this,empty())},1))}propertiesChangedCallback(e){}flushPropertyChanges(){clearTimeout(debouncers$1.get(this)),debouncers$1.delete(this),this.propertiesChangedCallback(batches$1.get(this)),batches$1.set(this,empty())}}),finalized$2=new WeakSet,properties=new WeakMap,PropertyAccessorsMixin=e=>(class t extends e{static setup(){if(!finalized$2.has(this)){for(const e in this.properties)Object.defineProperty(this.prototype,e,{configurable:!0,enumerable:!0,get:function(){return this.get(e)},set:function(t){this.set(e,t)}});finalized$2.add(this)}}constructor(){super(),t.setup(),properties.set(this,empty())}set(e,t){properties.get(this)[e]=t}get(e){return properties.get(this)[e]}connectedCallback(){const e=this.constructor;if(!has(e,"properties"))return;const t=Object.keys(e.properties);for(const e of t){const{required:s}=t[e];null==this[e]&&has(t[e],"default")?this[e]=t[e].default.call(this):s&&console.warn(`Required property '${e}' was not passed down to`,this)}super.connectedCallback&&super.connectedCallback()}}),finalized$3=new WeakSet,observedProperties$1=new WeakMap,PropertyChangedMixin=e=>(class t extends e{static setup(){if(!finalized$3.has(this)&&has(this,"properties")){if(this.observedProperties)observedProperties$1.set(this,new Set(this.observedProperties));else{const e=this.properties;observedProperties$1.set(this,new Set(Object.keys(e).filter(t=>!1!==e[t].observe)))}finalized$3.add(this)}}constructor(){super(),t.setup()}set(e,t){const s=this[e];super.set(e,t),observedProperties$1.get(this).has(e)&&this.propertyChangedCallback(e,s,t)}connectedCallback(){null!=super.connectedCallback?super.connectedCallback():(console.error("PropertyChangedMixin requires PropertyAccessorMixin to be applied first."),console.error("Source:",this));const e=this.constructor;if(!has(e,"properties"))return;const t=Object.keys(e.properties);for(const e of t){const s=t[e],{required:r}=s;null==this[e]&&has(s,"default")?this[e]=s.default.call(this):r&&console.warn(`Required property '${e}' was not passed down to`,this)}}propertyChangedCallback(e,t,s){}}),StaticTemplateMixin=e=>(class extends e{constructor(){super(),this.constructor.hasOwnProperty("template")&&this.attachShadow({mode:"open"})}connectedCallback(){const e=this.constructor;if(e.hasOwnProperty("template")){const t=e.template.content;this.shadowRoot.appendChild(t.cloneNode(!0))}super.connectedCallback&&super.connectedCallback()}});function sanitize(e){return e instanceof HTMLTemplateElement?e.innerHTML:String(e)}function html(e,...t){const s=e.raw,r=document.createElement("template");return r.innerHTML=t.reduce((e,t,r)=>e+sanitize(t)+s[r+1],s[0]),r}const ShadyCSS=window.ShadyCSS,emulated=!(null==ShadyCSS||ShadyCSS.nativeShadow&&ShadyCSS.nativeCss),finalized$4=new WeakSet,ShadyTemplateMixin=e=>{const t=StaticTemplateMixin(e);return class extends t{constructor(){super();const e=this.constructor;e.template&&!finalized$4.has(e)&&(emulated&&ShadyCSS.prepareTemplate(e.template,this.localName),finalized$4.add(e))}connectedCallback(){super.connectedCallback(),finalized$4.has(this.constructor)&&emulated&&ShadyCSS.styleElement(this),super.connectedCallback&&super.connectedCallback()}}};export{AttributeMixin,AttributesChangedMixin,connector,FocusMixin,MinimalMixin,PropertiesChangedMixin,PropertyAccessorsMixin,PropertyChangedMixin,ShadyTemplateMixin,StaticTemplateMixin,html};
