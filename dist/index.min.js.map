{"version":3,"file":"index.min.js","sources":["../src/utils.js","../src/attribute-mixin.js","../src/connector.js","../src/focus-mixin.js","../src/minimal-mixin.js","../src/properties-mixin.js","../src/static-template-mixin.js","../src/shady-template-mixin.js"],"sourcesContent":["export function toDashCase(str) {\r\n  return str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();\r\n}\r\n\r\nexport function toCamelCase(str) {\r\n  return str.replace(/-([a-z])/ig, (m) => m[1].toUpperCase());\r\n}\r\n\r\nexport function isBoolean(value) {\r\n  return value != null && (value === 'false' || value === 'true' || typeof value === 'boolean');\r\n}\r\n\r\nexport function toBoolean(value) {\r\n  return value !== 'false' && Boolean(value);\r\n}\r\n\r\nexport function has(target, prop) {\r\n  return target.hasOwnProperty(prop);\r\n}\r\n\r\nexport function empty() {\r\n  return Object.create(null);\r\n}\r\n\r\nexport function freeze(object) {\r\n  return Object.freeze(object);\r\n}\r\n\r\nexport const EMPTY = freeze(empty());\r\n\r\nconst timeouts = new WeakMap();\r\n\r\nexport function debounce(fn) {\r\n  const wrapper = () => {\r\n    fn();\r\n    timeouts.delete(fn);\r\n  }\r\n\r\n  return () => {\r\n    clearTimeout(timeouts.get(fn));\r\n    timeouts.set(fn, setTimeout(wrapper, 1));\r\n  }\r\n}\r\n\r\nconst called = new WeakSet();\r\n\r\nexport function once(fn) {\r\n  return () => {\r\n    if (!called.has(fn)) {\r\n      fn();\r\n      called.add(fn);\r\n    }\r\n  }\r\n}\r\n\r\nconst input = new WeakMap();\r\nconst output = new WeakMap();\r\n\r\nexport function cache(fn) {\r\n  return (...args) => {\r\n    const previous = input.get(fn);\r\n    const equal = args.every((item, i) => item === previous[i]);\r\n    if (equal) {\r\n      return output.get(fn);\r\n    } else {\r\n      const result = fn(...args);\r\n      input.set(fn, args);\r\n      output.set(fn, result);\r\n      return result;\r\n    }\r\n  }\r\n}\r\n","import { toDashCase } from './utils.js';\r\n\r\nfunction getter(type, key) {\r\n  switch (type) {\r\n    case String:\r\n      return function() {\r\n        return this.getAttribute(key);\r\n      };\r\n    case Boolean:\r\n      return function() {\r\n        return this.hasAttribute(key);\r\n      };\r\n    case Number:\r\n      return function() {\r\n        return Number(this.getAttribute(key));\r\n      };\r\n  }\r\n}\r\n\r\nfunction setter(type, key) {\r\n  switch (type) {\r\n    case String:\r\n    case Number:\r\n      return function(v) {\r\n        this.setAttribute(key, v);\r\n      };\r\n    case Boolean:\r\n      return function(v) {\r\n        this.toggleAttribute(key, v);\r\n      };\r\n  }\r\n}\r\n\r\nconst finalized = new WeakSet();\r\n\r\n/**\r\n * A very simple mixin for synchronizing primitive properties with attributes.\r\n * Maps `camelCase` properties to `dash-case` attributes.\r\n * `String` property values map directly to attribute values.\r\n * `Boolean` property values toggle the existence of attributes.\r\n * `Number` property values are coerced with `Number()`.\r\n * Note: This mixin prohibits the use of `PropertiesMixin`.\r\n */\r\nexport const AttributeMixin = (SuperClass) => (class AttributeElement extends SuperClass {\r\n  constructor() {\r\n    super();\r\n    const ctor = this.constructor;\r\n    if (finalized.has(ctor) || !ctor.hasOwnProperty('properties')) {\r\n      return;\r\n    }\r\n\r\n    const properties = ctor.properties;\r\n    const prototype = ctor.prototype;\r\n    for (const key in properties) {\r\n      const { type, reflect } = properties[key];\r\n      if (reflect) {\r\n        const attribute = toDashCase(key);\r\n        Object.defineProperty(prototype, key, {\r\n          configurable: true,\r\n          enumerable: true,\r\n          get: getter(type, attribute),\r\n          set: setter(type, attribute)\r\n        });\r\n      }\r\n    }\r\n\r\n    finalized.add(ctor);\r\n  }\r\n\r\n  /**\r\n   * Toggle an attribute.\r\n   * @param {String} name name of the attribute to toggle.\r\n   * @param {Boolean} predicate decides whether to set or remove the attribute.\r\n   */\r\n  toggleAttribute(name, predicate) {\r\n    if (predicate != null) {\r\n      if (predicate) {\r\n        this.setAttribute(name, '');\r\n      } else {\r\n        this.removeAttribute(name);\r\n      }\r\n    } else {\r\n      if (this.hasAttribute(name)) {\r\n        this.removeAttribute(name);\r\n      } else {\r\n        this.setAttribute(name, '');\r\n      }\r\n    }\r\n  }\r\n});\r\n","const subscriptions = new WeakMap();\r\n\r\nexport const connector = (store) => (\r\n  (SuperClass, map) => class extends SuperClass {\r\n    connectedCallback() {\r\n      const { selectors, actions } = map;\r\n\r\n      if (selectors) {\r\n        const update = () => Object.assign(\r\n          this,\r\n          selectors(store.getState())\r\n        );\r\n        subscriptions.set(this, store.subscribe(update));\r\n        update();\r\n      }\r\n\r\n      if (actions) {\r\n        const dispatchers = actions(store.dispatch);\r\n        for (const type in dispatchers) {\r\n          this.addEventListener(type, event => {\r\n            event.stopImmediatePropagation();\r\n            dispatchers[type](event.detail);\r\n          });\r\n        }\r\n      }\r\n\r\n      if (super.connectedCallback) {\r\n        super.connectedCallback();\r\n      }\r\n     }\r\n\r\n    disconnectedCallback() {\r\n      if (map.selectors) {\r\n        const unsubscribe = subscriptions.get(this);\r\n        unsubscribe();\r\n      }\r\n      if (super.disconnectedCallback) {\r\n        super.disconnectedCallback();\r\n      }\r\n    }\r\n  }\r\n);\r\n","export const FocusMixin = (SuperClass) => (class FocusableElement extends SuperClass {\r\n  static get observedAttributes() {\r\n    return (super.observedAttributes || []).concat(['disabled']);\r\n  }\r\n\r\n  set disabled(v) {\r\n    if (v) {\r\n      this.setAttribute('disabled', '');\r\n    } else {\r\n      this.removeAttribute('disabled');\r\n    }\r\n  }\r\n\r\n  get disabled() {\r\n    return this.hasAttribute('disabled');\r\n  }\r\n\r\n  set focused(v) {\r\n    if (v) {\r\n      this.setAttribute('focused', '');\r\n    } else {\r\n      this.removeAttribute('focused');\r\n    }\r\n  }\r\n\r\n  get focused() {\r\n    return this.hasAttribute('focused');\r\n  }\r\n\r\n  attributeChangedCallback(attr, oldValue, newValue) {\r\n    if (attr === 'disabled') {\r\n      const hasValue = newValue != null;\r\n      this.setAttribute('aria-disabled', hasValue);\r\n      if (hasValue) {\r\n        // Remove attribute entirely to ensure that the\r\n        // element is no longer focusable\r\n        this.removeAttribute('tabindex');\r\n        this.blur();\r\n      } else {\r\n        this.setAttribute('tabindex', '0');\r\n      }\r\n    }\r\n\r\n    if (super.attributeChangedCallback) {\r\n      super.attributeChangedCallback(attr, oldValue, newValue);\r\n    }\r\n  }\r\n\r\n  connectedCallback() {\r\n    this.addEventListener('focus', this.onFocus.bind(this));\r\n    this.addEventListener('blur', this.onBlur.bind(this));\r\n\r\n    if (!this.hasAttribute('tabindex') && !this.disabled) {\r\n      this.setAttribute('tabindex', '0');\r\n    }\r\n\r\n    if (super.connectedCallback) {\r\n      super.connectedCallback();\r\n    }\r\n  }\r\n\r\n  focus() {\r\n    super.focus();\r\n    if (!this.disabled) {\r\n      this.dispatchEvent(new Event('focus'));\r\n    }\r\n  }\r\n\r\n  onFocus(event) {\r\n    this.focused = true;\r\n  }\r\n\r\n  blur() {\r\n    super.blur();\r\n    this.dispatchEvent(new Event('blur'));\r\n  }\r\n\r\n  onBlur(event) {\r\n    this.focused = false;\r\n  }\r\n});\r\n","export const MinimalMixin = (SuperClass) => class MinimalElement extends SuperClass {\r\n  /**\r\n   * Convenience function for emitting a custom event.\r\n   * @param {string} type \r\n   * @param {*} detail \r\n   * @param {CustomEventInit} options \r\n   */\r\n  emit(type, detail, options) {\r\n    const init = Object.assign({\r\n      bubbles: true,\r\n      cancelable: true,\r\n      detail\r\n    }, options);\r\n    return this.dispatchEvent(new CustomEvent(type, init));\r\n  }\r\n\r\n  /**\r\n   * Toggle an attribute.\r\n   * @param {String} name name of the attribute to toggle.\r\n   * @param {Boolean} predicate decides whether to set or remove the attribute.\r\n   */\r\n  toggleAttribute(name, predicate) {\r\n    if (predicate != null) {\r\n      if (predicate) {\r\n        this.setAttribute(name, '');\r\n      } else {\r\n        this.removeAttribute(name);\r\n      }\r\n    } else {\r\n      if (this.hasAttribute(name)) {\r\n        this.removeAttribute(name);\r\n      } else {\r\n        this.setAttribute(name, '');\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { toDashCase, toCamelCase, has, empty } from './utils.js';\r\n\r\nfunction isPrimitive(type) {\r\n  switch (type) {\r\n    case String:\r\n    case Number:\r\n    case Boolean:\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nconst finalized = new WeakSet();\r\nconst properties = new WeakMap();\r\nconst observers = new WeakMap();\r\nconst batches = new WeakMap();\r\nconst debouncers = new WeakMap();\r\n\r\nfunction setter(key) {\r\n  return function(newValue) {\r\n    const oldValue = properties.get(this)[key];\r\n    properties.get(this)[key] = newValue;\r\n    const obs = observers.get(this.constructor)[key];\r\n    const len = obs.length;\r\n    for (let i = 0; i < len; i++) {\r\n      obs[i].call(this, key, oldValue, newValue);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getter(key) {\r\n  return function() {\r\n    return properties.get(this)[key];\r\n  }\r\n}\r\n\r\nfunction reflector(type, attributeName) {\r\n  switch (type) {\r\n    case Number:\r\n    case String:\r\n      return function(_, __, newValue) {\r\n        this.setAttribute(attributeName, newValue);\r\n      }\r\n    case Boolean:\r\n      return function(_, __, newValue) {\r\n        if (newValue) {\r\n          this.setAttribute(attributeName, '');\r\n        } else {\r\n          this.removeAttribute(attributeName);\r\n        }\r\n      }\r\n  }\r\n}\r\n\r\nfunction propertyChanged(name, oldValue, newValue) {\r\n  this.propertyChangedCallback(name, oldValue, newValue);\r\n}\r\n\r\nfunction propertiesChanged(name, oldValue, newValue) {\r\n  const batch = batches.get(this);\r\n  if (batch[name]) {\r\n    batch[name].newValue = newValue;\r\n  } else {\r\n    batch[name] = {\r\n      name,\r\n      oldValue,\r\n      newValue\r\n    };\r\n  }\r\n\r\n  clearTimeout(debouncers.get(this)); \r\n  debouncers.set(this, setTimeout(() => {\r\n    this.propertiesChangedCallback(batch);\r\n    batches.set(this, empty());\r\n  }, 1));\r\n}\r\n\r\nexport const PropertiesMixin = (SuperClass) => (class PropertiesElement extends SuperClass {\r\n  // Has to be constructed like so,\r\n  // because values are read at define-time\r\n  // and the `properties` of the inheriting\r\n  // class is needed\r\n  static get observedAttributes() {\r\n    const props = this.properties;\r\n    return props ? Object.entries(props)\r\n      .filter(([prop, opts]) => isPrimitive(opts.type))\r\n      .map(([prop, opts]) => toDashCase(prop)) : [];\r\n  }\r\n\r\n  static setup() {\r\n    if (finalized.has(this)) {\r\n      return;\r\n    }\r\n\r\n    observers.set(this, empty());\r\n    this.mappedAttributes = new Set();\r\n\r\n    for (const key in this.properties) {\r\n      Object.defineProperty(this.prototype, key, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get: getter(key),\r\n        set: setter(key)\r\n      });\r\n\r\n      const { type, reflect, observe } = this.properties[key];\r\n\r\n      const obs = observers.get(this)[key] = [];\r\n      if (observe) {\r\n        obs.push(propertyChanged);\r\n        obs.push(propertiesChanged);\r\n      }\r\n\r\n      if (reflect) {\r\n        const attributeName = toDashCase(key);\r\n        this.mappedAttributes.add(attributeName);\r\n        obs.push(reflector(type, attributeName));\r\n      }\r\n    }\r\n\r\n    finalized.add(this);\r\n  }\r\n\r\n  constructor() {\r\n    super();\r\n    this.constructor.setup();\r\n    properties.set(this, empty());\r\n    batches.set(this, empty());\r\n  }\r\n\r\n  connectedCallback() {\r\n    const constructor = this.constructor;\r\n    if (!has(constructor, 'properties')) {\r\n      return;\r\n    }\r\n\r\n    const options = constructor.properties;\r\n    for (const key in options) {\r\n      const { type, required } = options[key];\r\n      let absent = this[key] == null;\r\n      let value;\r\n\r\n      // Attempt to read from attribute if absent\r\n      const attributeName = toDashCase(key);\r\n      if (absent && this.hasAttribute(attributeName)) {\r\n        const raw = this.getAttribute(attributeName);\r\n        this.removeAttribute(attributeName);\r\n\r\n        switch (type) {\r\n          case String:\r\n            value = raw;\r\n            break;\r\n          case Number:\r\n            value = Number(raw);\r\n            break;\r\n          case Boolean:\r\n            value = raw != null;\r\n            break;\r\n          default:\r\n            value = JSON.parse(raw);\r\n            break;\r\n        }\r\n\r\n        absent = value == null;\r\n        if (!absent) {\r\n          this[key] = value;\r\n        }\r\n      }\r\n\r\n      // if (still) absent, apply default value\r\n      if (absent && has(options[key], 'default')) {\r\n        this[key] = options[key].default.call(this);\r\n      } else if (required) {\r\n        console.warn(`Required property '${key}' was not passed down to`, this);\r\n      }\r\n    }\r\n\r\n    if (super.connectedCallback) {\r\n      super.connectedCallback();\r\n    }\r\n  }\r\n\r\n  attributeChangedCallback(attr, oldValue, newValue) {\r\n    if (\r\n      this.constructor.mappedAttributes.has(attr) &&\r\n      oldValue !== newValue\r\n    ) {\r\n      const prop = toCamelCase(attr);\r\n      const options = this.constructor.properties;\r\n      const type = options[prop] && options[prop].type || String;\r\n      const old = properties.get(this)[prop];\r\n      let updated;\r\n      switch (type) {\r\n        case String:\r\n          updated = newValue;\r\n          break;\r\n        case Number:\r\n          updated = Number(newValue);\r\n          break;\r\n        case Boolean:\r\n          updated = newValue != null;\r\n          break;\r\n      }\r\n\r\n      properties.get(this)[prop] = updated;\r\n      this.propertyChangedCallback(prop, old, updated);\r\n    }\r\n\r\n    if (super.attributeChangedCallback) {\r\n      super.attributeChangedCallback(attr, oldValue, newValue);\r\n    }\r\n  }\r\n\r\n  propertyChangedCallback(name, oldValue, newValue) {}\r\n\r\n  propertiesChangedCallback(changes) {}\r\n\r\n  flushPropertyChanges() {\r\n    clearTimeout(debouncers.get(this));\r\n    debouncers.delete(this);\r\n    this.propertiesChangedCallback(batches.get(this));\r\n    batches.set(this, empty());\r\n  }\r\n});\r\n","export const StaticTemplateMixin = (SuperClass) => (class StaticTemplateElement extends SuperClass {\r\n  constructor() {\r\n    super();\r\n    if (this.constructor.hasOwnProperty('template')) {\r\n      this.attachShadow({ mode: 'open' });\r\n    }\r\n  }\r\n\r\n  connectedCallback() {\r\n    const ctor = this.constructor;\r\n    if (ctor.hasOwnProperty('template')) {\r\n      const template = ctor.template.content;\r\n      this.shadowRoot.appendChild(template.cloneNode(true));\r\n    }\r\n\r\n    if (super.connectedCallback) {\r\n      super.connectedCallback();\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * @param {*} value Object to stringify into HTML\r\n * @return {string} HTML stringified form of `obj`\r\n */\r\nfunction sanitize(value) {\r\n  if (value instanceof HTMLTemplateElement) {\r\n    return value.innerHTML;\r\n  } else {\r\n    return String(value);\r\n  }\r\n}\r\n\r\n/**\r\n * A template literal tag that creates an HTML <template> element from the contents of the string.\r\n * @param {Array<string>} strings Constant parts of tagged template literal\r\n * @param {...*} values Variable parts of tagged template literal\r\n * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement\r\n */\r\nexport function html(strings, ...values) {\r\n  const rawStrings = strings.raw;\r\n  const template = document.createElement('template');\r\n  template.innerHTML = values.reduce((acc, v, idx) =>\r\n    acc + sanitize(v) + rawStrings[idx + 1], rawStrings[0]);\r\n  return template;\r\n}\r\n","import { StaticTemplateMixin } from './static-template-mixin.js';\r\n\r\nconst ShadyCSS = window.ShadyCSS;\r\nconst emulated = ShadyCSS != null && (\r\n  !ShadyCSS.nativeShadow ||\r\n  !ShadyCSS.nativeCss\r\n);\r\n\r\nconst finalized = new WeakSet();\r\n\r\nexport const ShadyTemplateMixin = (SuperClass) => {\r\n  const Base = StaticTemplateMixin(SuperClass);\r\n  return class ShadyTemplateElement extends Base {\r\n    constructor() {\r\n      super();\r\n      const ctor = this.constructor;\r\n      if (!ctor.template || finalized.has(ctor)) {\r\n        return;\r\n      }\r\n\r\n      if (emulated) {\r\n        ShadyCSS.prepareTemplate(ctor.template, this.localName);\r\n      }\r\n\r\n      finalized.add(ctor);\r\n    }\r\n\r\n    connectedCallback() {\r\n      super.connectedCallback();\r\n      if (finalized.has(this.constructor)) {\r\n        if (emulated) {\r\n          ShadyCSS.styleElement(this);\r\n        }\r\n      }\r\n\r\n      if (super.connectedCallback) {\r\n        super.connectedCallback();\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"names":["toDashCase","str","replace","toLowerCase","toCamelCase","m","toUpperCase","has","target","prop","hasOwnProperty","empty","Object","create","freeze","object","EMPTY","getter","type","key","String","this","getAttribute","Boolean","hasAttribute","Number","setter","v","setAttribute","toggleAttribute","finalized","WeakSet","AttributeMixin","SuperClass","[object Object]","super","ctor","constructor","properties","prototype","reflect","attribute","defineProperty","configurable","enumerable","get","set","add","name","predicate","removeAttribute","subscriptions","WeakMap","connector","store","map","selectors","actions","update","assign","getState","subscribe","dispatchers","dispatch","addEventListener","event","stopImmediatePropagation","detail","connectedCallback","unsubscribe","disconnectedCallback","FocusMixin","observedAttributes","concat","disabled","focused","attr","oldValue","newValue","hasValue","blur","attributeChangedCallback","onFocus","bind","onBlur","focus","dispatchEvent","Event","MinimalMixin","options","init","bubbles","cancelable","CustomEvent","isPrimitive","observers","batches","debouncers","obs","len","length","i","call","reflector","attributeName","_","__","propertyChanged","propertyChangedCallback","propertiesChanged","batch","clearTimeout","setTimeout","propertiesChangedCallback","PropertiesMixin","props","entries","filter","opts","mappedAttributes","Set","observe","push","setup","required","value","absent","raw","JSON","parse","default","console","warn","old","updated","changes","delete","StaticTemplateMixin","attachShadow","mode","template","content","shadowRoot","appendChild","cloneNode","sanitize","HTMLTemplateElement","innerHTML","html","strings","values","rawStrings","document","createElement","reduce","acc","idx","ShadyCSS","window","emulated","nativeShadow","nativeCss","ShadyTemplateMixin","Base","prepareTemplate","localName","styleElement"],"mappings":"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"}